package org.ricebin.sstable;

import org.ricebin.slice.Slice;

public class BloomFilterPolicy implements FilterPolicy {

  public static final String NAME = "leveldb.BuiltinBloomFilter2";

  // https://github.com/google/leveldb/blob/master/util/bloom.cc#L26
  public static final BloomFilterPolicy LEVELDB_BUILTIN_BLOOM_FILTER2 =
      new BloomFilterPolicy("leveldb.BuiltinBloomFilter2", 0xbc9f1d34);

  private class ReaderImpl implements Reader {

    @Override
    public String name() {
      return name;
    }

    // https://github.com/google/leveldb/blob/f57513a1d6c99636fc5b710150d0b93713af4e43/util/bloom.cc#L56
    @Override
    public boolean keyMayMatch(Slice key, Slice filter) {
      int len = filter.len();
      if (len < 2) {
        return false;
      }

      int bits = (len - 1) * 8;

      // Use the encoded k so that we can read filters generated by
      // bloom filters created using different parameters.
      int k = filter.getByte(len - 1);
      if (k > 30) {
        // Reserved for potentially new encodings for short bloom filters.
        // Consider it a match.
        return true;
      }

      long h = bloomHash(key, seed);
      long delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
      for (int j = 0; j < k; j++) {
        int bitpos = (int) (h % bits);
        if ((filter.getByte(bitpos / 8) & (1 << (bitpos % 8))) == 0) {
          return false;
        }
        h += delta;
      }
      return true;
    }
  }

  static long bloomHash(Slice input, int seed) {
    return toUnsigned(Hash.hash(input, seed));
  }

  private static long toUnsigned(int h) {
    return h & 0xffffffffL;
  }

  private final String name;
  private final int seed;

  private BloomFilterPolicy(String name, int seed) {
    this.name = name;
    this.seed = seed;
  }

  @Override
  public Reader getReader() {
    return new ReaderImpl();
  }
}
