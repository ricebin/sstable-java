package org.ricebin.sstable;

import java.util.Collection;
import org.ricebin.slice.Slice;

public class BloomFilterPolicy implements FilterPolicy {

  // https://github.com/google/leveldb/blob/master/util/bloom.cc#L26
  public static final BloomFilterPolicy LEVELDB_BUILTIN_BLOOM_FILTER2 =
      new BloomFilterPolicy("leveldb.BuiltinBloomFilter2", 0xbc9f1d34);

  private class ReaderImpl implements Reader {

    @Override
    public String name() {
      return name;
    }

    // https://github.com/google/leveldb/blob/f57513a1d6c99636fc5b710150d0b93713af4e43/util/bloom.cc#L56
    @Override
    public boolean keyMayMatch(Slice key, Slice filter) {
      int len = filter.len();
      if (len < 2) {
        return false;
      }

      int bits = (len - 1) * 8;

      // Use the encoded k so that we can read filters generated by
      // bloom filters created using different parameters.
      int k = filter.getByte(len - 1);
      if (k > 30) {
        // Reserved for potentially new encodings for short bloom filters.
        // Consider it a match.
        return true;
      }

      long h = bloomHash(key, seed);
      long delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
      for (int j = 0; j < k; j++) {
        int bitpos = (int) (h % bits);
        if ((filter.getByte(bitpos / 8) & (1 << (bitpos % 8))) == 0) {
          return false;
        }
        h += delta;
      }
      return true;
    }
  }

  private class WriterImpl implements Writer {

    private final int bitsPerKey;
    private final int k;

    private WriterImpl(int bitsPerKey) {
      // We intentionally round down to reduce probing cost a little bit
      this.bitsPerKey = bitsPerKey;
      int k = (int) (bitsPerKey * 0.69);
      if (k < 1) {
        k = 1;
      } else if (k > 30) {
        k = 30;
      }
      this.k = k;
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public byte[] createFilter(Collection<Slice> keys) {
      // Compute bloom filter size (in both bits and bytes)
      int bits = keys.size() * bitsPerKey;

      // For small n, we can see a very high false positive rate.  Fix it
      // by enforcing a minimum bloom filter length.
      if (bits < 64) {
        bits = 64;
      }

      int bytes = (bits + 7) / 8;
      bits = bytes * 8;

      final byte[] array = new byte[bytes + 1];
      array[array.length - 1] = (byte) k; // Remember # of probes in filter

      for (Slice key : keys) {
        // Use double-hashing to generate a sequence of hash values.
        // See analysis in [Kirsch,Mitzenmacher 2006].
        long h = bloomHash(key, seed);
        long delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
        for (int j = 0; j < k; j++) {
          int bitpos = (int) (h % bits);
          int i = bitpos / 8;
          array[i] |= (1 << (bitpos % 8));
          h += delta;
        }
      }
      return array;
    }
  }

  static long bloomHash(Slice input, int seed) {
    return toUnsigned(Hash.hash(input, seed));
  }

  private static long toUnsigned(int h) {
    return h & 0xffffffffL;
  }

  private final String name;
  private final int seed;

  private BloomFilterPolicy(String name, int seed) {
    this.name = name;
    this.seed = seed;
  }

  public Reader getReader() {
    return new ReaderImpl();
  }

  public Writer getWriter(int bitsPerKey) {
    return new WriterImpl(bitsPerKey);
  }
}
